#!/usr/bin/env python3
"""
Exploit for Elliptic Contribution challenge - Small subgroup attack
Author: AI Agent
Purpose: Perform small subgroup attack to recover AES key and decrypt flag
Created: 2025-11-20 13:30
Last Updated: 2025-11-20 13:30
Expected Result: Decrypt and obtain the flag
Produced Result: TBD
"""

import socket
from sage.all import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# Curve parameters
a = Integer(0x426b522d14487e10aa36de8bfd0f807c2db07551727ea79e1c8670bfa1b6f4f1)
b = Integer(0x2f76b6d71e3ec56f0fd49703151b3ea66bd4fd713e8630fbf461772e2088e2a7)
p = Integer(0x7fad2d5ec5d28f0acf09bdc1d2e663ec78c6473858e34191e12c37fc25b8dd39)

# Point of small order
offering = 51631284073615627134841947443948396988494501746634252996757337199954429502767
small_order = 1333357

print(f"[*] Setting up elliptic curve...")
E = EllipticCurve(GF(p), [a, b])
G = E(51631284073615627134841947443948396988494501746634252996757337199954429502767,
       25176919791555448994575578952129731315990778033436857918209915706796594579662)
print(f"[*] Generator point order: {G.order()}")
print()

# Connect to server and get encrypted flag
print(f"[*] Connecting to server...")
HOST = "154.57.164.73"
PORT = 31881

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(30)
s.connect((HOST, PORT))

# Receive initial prompt
s.recv(4096)

# Send option 2 with our offering
print(f"[*] Sending offering: {offering}")
s.send(b"2\n")
s.recv(4096)  # Receive the offering prompt

s.send(f"{offering}\n".encode())
response = s.recv(8192).decode()
print(f"[*] Response received")

# Extract the hex encrypted data
import re
print(f"[*] Response: {response}")
match = re.search(r':: ([0-9a-f]+)', response)
if match:
    enc_hex = match.group(1)
    enc_data = bytes.fromhex(enc_hex)
    print(f"[*] Encrypted data length: {len(enc_data)} bytes")

    iv = enc_data[:16]
    ciphertext = enc_data[16:]
    print(f"[*] IV: {iv.hex()}")
    print(f"[*] Ciphertext: {ciphertext.hex()}")
else:
    print("[-] Failed to extract encrypted data")
    s.close()
    exit(1)

s.close()
print()

# Brute force x mod small_order
print(f"[*] Brute forcing x mod {small_order}...")
print(f"[*] This will try {small_order} possibilities...")

for x_mod in range(small_order):
    if x_mod % 10000 == 0:
        print(f"    Progress: {x_mod}/{small_order} ({100*x_mod//small_order}%)")

    # Compute G*x_mod
    try:
        point = G * x_mod
        x_coord = int(point[0])

        # Convert to AES key
        key = int.to_bytes(x_coord, length=(x_coord.bit_length()+7)//8, byteorder='big')

        # Try to decrypt
        try:
            cipher = AES.new(key, AES.MODE_CBC, iv)
            plaintext = cipher.decrypt(ciphertext)
            decrypted = unpad(plaintext, 16)

            # Check if it looks like a flag
            if b'HTB{' in decrypted or b'FLAG{' in decrypted or decrypted.startswith(b'HTB') or decrypted.startswith(b'FLAG'):
                print(f"\n[+] SUCCESS!")
                print(f"[+] Found x mod {small_order} = {x_mod}")
                print(f"[+] Key: {key.hex()}")
                print(f"[+] Flag: {decrypted.decode()}")
                break
        except:
            pass
    except:
        pass
else:
    print("[-] Failed to find the correct x value")

print("\n[*] Attack complete")
