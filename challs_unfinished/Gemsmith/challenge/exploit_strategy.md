# Exploitation Strategy via delete()

## Key Insight from User
**"so you want to get to delete() then"**

This suggests delete() is special and central to the solution.

## Why delete() is Special

1. **Only safe operation**: delete() → success() → returns normally (NO exit!)
2. **UAF vulnerability**: After delete(), buf[0] still points to freed chunk
3. **Can be called multiple times**: Unlike fail() which exits

## Exploitation Paths

### Path 1: Information Leak via UAF
```
1. Alloc chunk A (malloc returns heap address)
2. Delete chunk A (free to tcache, UAF - buf[0] still points to it)
3. Show() - calls puts(buf[0]) which now contains tcache metadata
   → This leaks heap addresses!
```

### Path 2: Tcache Poisoning
```
GLIBC 2.27 tcache properties:
- No double-free detection
- No size checks
- Minimal integrity checks

Exploit:
1. Alloc chunk (0x1000 bytes)
2. Delete chunk (goes to tcache)
3. Use NULL write to corrupt tcache->next pointer
4. Next alloc() returns controlled address
5. Write arbitrary data to that address
```

### Path 3: Double-Free via UAF
```
1. Alloc chunk
2. Delete chunk (free, UAF remains)
3. Delete chunk AGAIN via UAF (double-free!)
   → Corrupts tcache bin
4. Subsequent allocs return corrupted addresses
```

### Path 4: Pattern Recognition
```
Maybe the server detects a specific pattern of operations?
- X number of delete() calls?
- Specific sequence of alloc/delete?
- Heap state after 14 operations?
```

## Testing Plan

1. ✓ Test show() after delete() - check for tcache leaks
2. ✓ Test double-free via UAF
3. Try different byte counts for NULL write corruption
4. Test patterns: all deletes, alternating alloc/delete, etc.

## Memory Layout Reminder
```
0x303010: stdout pointer (BEFORE buf)
0x303020: stdin pointer (BEFORE buf)
0x303030: buf[0] ← our pointer
0x304000: heap start ← tcache bins here

NULL write goes FORWARD only (can corrupt heap, not globals)
```

## Next Steps

Focus on delete() as the core primitive:
- It's safe (doesn't exit)
- It has UAF
- It can be used in combinations

The solution likely involves:
1. Using delete() multiple times strategically
2. Leveraging UAF to corrupt tcache
3. Getting arbitrary write capability
4. Overwriting something that changes program behavior

**Key Question**: What can we overwrite with arbitrary write that would:
- Prevent the final fail() call?
- Make the server return the flag?
- Change program flow to success()?
