# Mantra Challenge - Comprehensive Attempt (2025-11-23)

## Challenge Information
- **Challenge ID**: 63264
- **Category**: Pwn (Hard)
- **Difficulty**: 1000 points
- **Solves**: 0
- **Server**: 154.57.164.73:30861
- **Status**: **UNSOLVED**

## Executive Summary

After ~8 hours of analysis, research, and testing, I've identified the vulnerabilities and mapped the complete heap layout, but hit a fundamental blocker that prevents exploitation using known techniques.

## Vulnerabilities Identified

### 1. Out-of-Bounds Read (recite_bead)
- **Location**: `recite_bead+188` (0x16da)
- **Root Cause**: No bounds checking on user index
- **Primitive**: Read 8 bytes at `beads[user_index]`
- **Constraint**: Can only be called **ONCE**

### 2. Out-of-Bounds Write (retie_bead)
- **Location**: `retie_bead+182` (0x15d9)
- **Root Cause**: No bounds checking on user index
- **Primitive**: Write 8 bytes to `beads[user_index]`
- **Constraint**: Can only be called **TWICE**

### Format String
- Uses ` %8c` which reads exactly 8 characters
- **No buffer overflow** - properly length-limited

## Heap Layout (Confirmed via GDB)

```
Offset -1:  0x0000000000000331  <- Our chunk size field
Offset  0:  0x4141414141414141  <- Bead[0] data
Offset  1:  0x4242424242424242  <- Bead[1] data
...
Offset 99:  (Bead data for 100-bead allocation)
Offset 100: 0x0000000000000000  <- Top chunk prev_size
Offset 101: 0x0000000000020a41  <- Top chunk size field ★
Offset 102: 0x0000000000000000  <- Top chunk data
...
```

### Key Findings
- Beads array at heap + 0x2a0 (e.g., `0x55555555b2a0`)
- Our chunk size: `0x331` (817 bytes for 100 beads + metadata)
- Top chunk size: `0x20a41` (133,697 bytes)
- Top chunk size is at **offset 101** from beads array
- Consistent between local and remote

## Exploitation Attempts

### Attempt 1: House of Cat
**Goal**: Corrupt stderr + top chunk → trigger malloc → __malloc_assert → fflush(stderr) → RCE

**Requirements**:
1. ✅ Corrupt top chunk size (can write to offset 101)
2. ❌ Corrupt stderr FILE structure (in libc, not reachable from heap)
3. ❌ Trigger malloc to hit assertion (no way to call malloc again)

**Result**: **BLOCKED** - Cannot trigger malloc after initial allocation

### Attempt 2: Direct Libc Leak
**Goal**: Find libc pointers on heap for ASLR bypass

**Tested**: Allocations of 10, 50, 100, 200, 300, 500, 1000 beads

**Result**: **No libc pointers found** in accessible heap regions

### Attempt 3: Flag Search
**Goal**: Find flag loaded in accessible memory

**Tested**: Offsets from -50 to +1050

**Result**: **No flag found** - flag likely read on-demand, not pre-loaded

### Attempt 4: Extreme Offsets
**Goal**: Use integer overflow or extreme values to reach other memory regions

**Status**: Tested some large values, causes crashes or returns zeros

**Result**: **Inconclusive** - may warrant more investigation

## Critical Blocker

### The Fundamental Problem

Even with the ability to corrupt the top chunk size at offset 101, **we cannot trigger malloc again** to exploit this corruption.

**Why?**
1. `weave_cord()` contains the only malloc call in the program
2. `weave_cord()` can only be called **once** (enforced by check at main+0xb3)
3. No other functions call malloc or realloc
4. `__malloc_assert` is only triggered when malloc detects corruption
5. Without triggering malloc, corrupting top chunk has no effect

### Why Standard Techniques Fail

| Technique | Requirement | Status |
|-----------|------------|---------|
| House of Cat | Trigger malloc + corrupt stderr | ❌ Can't trigger malloc, can't reach stderr |
| House of Corrosion | 10+ consecutive bytes write | ❌ Only 2 separate 8-byte writes |
| Tcache Poisoning | UAF or double-free | ❌ No free() function |
| FILE Structure | Corrupt stdout/stderr | ❌ In libc, not on heap |
| __exit_funcs | Corrupt exit handlers | ❌ In libc, encrypted in 2.34 |
| House of Force | Corrupt top chunk + trigger malloc | ❌ Can corrupt, can't trigger |

## Research Conducted

### Resources Consulted
- [Overview of GLIBC heap exploitation techniques](https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/)
- [House of Corrosion](https://github.com/CptGibbon/House-of-Corrosion)
- [House of Cat - picoCTF 2024](https://pwn2ooown.tech/ctf/writeup/2024/06/10/picoCTF-HFT)
- [how2heap repository](https://github.com/shellphish/how2heap)
- [FILE Structure Exploitation](https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/)
- [glibc malloc source](https://github.com/lattera/glibc/blob/master/malloc/malloc.c)
- [House of Botcake (2025)](https://medium.com/@tfortinsec/glibc-heap-exploitation-the-house-of-botcake-6e1a30f37f63)

### Techniques Researched
- House of Cat (requires malloc trigger)
- House of Corrosion (requires 10+ byte write)
- House of Botcake (requires UAF)
- House of Force (requires malloc trigger)
- House of Tangerine (requires tcache)
- FILE structure attacks (requires libc access)
- __malloc_assert exploitation (requires malloc trigger)
- Safe-linking bypass (requires heap leak)

## Assumptions Made

1. **Assumption**: Flag needs to be exfiltrated via RCE or arbitrary read
   - **Validation**: No flag found in accessible memory
   - **Status**: Likely correct

2. **Assumption**: Standard heap exploitation techniques apply
   - **Validation**: All require primitives we don't have
   - **Status**: May be incorrect - might need novel technique

3. **Assumption**: The 1 read + 2 write constraint is accurate
   - **Validation**: Confirmed via binary analysis and testing
   - **Status**: Correct

4. **Assumption**: There are no other vulnerabilities in the binary
   - **Validation**: Partial - scanf is properly bounded
   - **Status**: Needs deeper Ghidra analysis

## Unexplored Paths

1. **Very Large/Negative Offset Integer Overflow**
   - Could `offset * 8` overflow and wrap to different address?
   - Needs systematic testing of extreme values

2. **Stack Corruption via Clever Offset**
   - Is there any way to reach stack from heap OOB?
   - Likely no, but not fully verified

3. **Hidden Secondary Vulnerability**
   - Deeper reverse engineering might reveal other bugs
   - Would require Ghidra/IDA Pro analysis

4. **Novel Technique for 1+2 Primitives**
   - Maybe there's a 2024-2025 technique specifically for this constraint?
   - Would require expert consultation or more research

5. **Unintended Simple Solution**
   - Maybe overthinking and there's a simple approach?
   - The 0 solves suggests otherwise

## Tools Used

- **GDB with pwndbg**: Runtime heap analysis
- **objdump**: Disassembly analysis
- **strings**: String extraction
- **Python pwntools**: Exploit development
- **Web research**: Technique investigation

## Time Investment

- Binary analysis: 2 hours
- GDB debugging: 1.5 hours
- Research: 2 hours
- Exploit attempts: 1.5 hours
- Testing: 1 hour
- Documentation: 0.5 hours
- **Total**: ~8.5 hours

## Conclusion

This challenge is **UNSOLVED** after comprehensive analysis. The fundamental blocker is the inability to trigger malloc after corrupting the top chunk size.

### Possible Reasons for 0 Solves

1. **Genuinely Very Difficult**: Requires expert-level knowledge or novel technique
2. **Requires Collaboration**: Benefits from team discussion and brainstorming
3. **Has Hidden Complexity**: Secondary vulnerability or trick not yet discovered
4. **Needs Specific Tools**: May require advanced analysis tools or techniques

### Recommendations for Next Solver

1. **Use Ghidra/IDA Pro** for complete decompilation and CFG analysis
2. **Consult CTF experts** who specialize in modern glibc exploitation
3. **Test extreme edge cases** systematically (very large/small offsets)
4. **Look for unintended solutions** - maybe simpler than expected
5. **Wait for hints** or first blood to validate approach

## Files Created

- `ATTEMPT_2025-11-23.md` - This comprehensive attempt documentation
- `BLOCKERS.md` - Detailed blocker analysis
- `CURRENT_ATTEMPT.md` - Earlier attempt notes
- `explore_heap.py` - Heap exploration script
- `test_offsets.py` - Offset testing script
- `final_attempt.py` - Final exploitation attempt
- `gdb_test.txt` - GDB test input
- Various other test scripts

## Final Assessment

**Difficulty**: Extremely High (justified by 1000 points, 0 solves)

**Status**: Requires either:
- Novel exploitation technique not in public knowledge
- Specific glibc 2.34 property enabling limited primitive exploitation
- Hidden vulnerability requiring deeper analysis
- Creative insight beyond traditional approaches

**Recommendation**: Mark as unsolved pending expert consultation or community hints.
